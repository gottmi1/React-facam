기본 : 라이브러리는 그들이 만든 목적과 도구의 사용법을 정리해뒀다
문서 리딩 및 예제를 반복, 숙달하며 공식문서에 익숙해져야 한다

익스텐션을 사용한 숏컷

react snippets 확장 프로그램을 받으면 rfc 익스텐션으로 리액트 펑션컴포넌트를 바로 만들 수 있음.
rcc는 클래스형 컴포넌트

1. 공식문서에서의 jsx

js를 확장한 문법. React의 엘리먼트를 생성한다.
React.createElement의 간편 표현식이다.

UI로직과 렌더링 로직이 연결되기 때문에 컴포넌트라는 유닛으로 묶어준다

따옴표를 사용하여 문자열 리터럴을 정의할 수 있고
중괄호를 사용하여 자바스크립트 표현식도 사용할 수 있다

React.createElement('h1', {className="zz"}, 'zdzd' )
를
<h1 className="zz">zdzd</h1>식으로 바꿔줌


2. 공식문서 에서의 컴포넌트와 Props

컴포넌트의 첫 글자는 반드시 대문자여야 하는데 이유는 기존의 html의 
태그나 프로퍼티와 중복될 수가 있기 때문이다.

컴포넌트 합성
부모 컴포넌트에 밖에있는 다른 컴포넌트를 요소로서 넣을 수가 있다.


컴포넌트 추출
유의미한 값들을 추출해서 새로운 컴포넌트를 만드는 것
재사용성을 높이는 방법 중 하나.

한 컴포넌트에 여러가지가 들어가는 것 보다 그걸 분해해서 여러가지 컴포넌트로 만들어놓는다면 재사용이 가능해서 편하다. 특히 버튼등. 작은 앱에선 굳이 왜하나싶지만 큰 앱에서 작업할 때 몹시 편함.

Props
props는 읽기 전용이다
입력값을 바꾸지 않고 입력값에 대해 동일한 결과를 반환하는데, 이것을 순순함수라고 한다.
모든 React 컴포넌트는 자신의 props를 다룰 때 항상 순수 함수처럼 동작해야 한다.

정리 : 
props -> 컴포넌트에 전달되는 단일 객체. 는 모든 프로퍼티를 포함하고 있기 때문에 props.name 식으로 하나의 값에만 접근하는 것도 가능.
컴포넌트 합성 작은 컴포넌트를 여러개 모아 한 컴포넌트를 만들 수 있음
컴포넌트 추출 여러곳에서 사용되거나 크고 복잡한 경우 요소요소를 따로 컴포넌트로 지정할 수 있음


3. 공식문서로 보는 State 와 생명주기(LifeCycle)

hook들이 나오기 전에는 함수형 컴포넌트에서 상태관리를 할 수가 없었다 hook을 사용하고 부터 상태 관리가 가능해짐(보통 더 많이 쓰인다고 한다)
중요한 점은 생명주기를 useEffect만으로 대체할 수 있다는 점.

정리 : 
컴포넌트 내의 상태) 자신의 출력값만 변경(props는 변경하면 안됨)
클래스 컴포넌트) 스테이트의 라이프사이클 별로 메서드가 있는데 그걸 통해서 상태를 관리함
함수 컴포넌트 에선 hook으로 관리함.
유의사항) 직접 수정이 불가능하고 비동기적일 수 있음.
State를 직접 설정하면 안된다 클래스 컴포넌트에선 this.state식으로 접근하기 떄문에 값을 변경할 수가 있는데 그렇게 하면 리렌더링이 되지 않으니 그렇게 사용하면 안된다.
State의 업데이트는 비동기적일 수 있다.

결론 : 함수 컴포넌트로도 클래스 컴포넌트와 똑같은 동작을 할 수 있고 그 안에서 상태관리가 가능하다.

3-2. 생명주기(LifeCycle)

툴을 쓸 때 어떤 타이밍에 어떤 순서로 동작이 일어나는가 하는 생성되고 사라지는 주기를 가르킨다

클래스 컴포넌트에서 this 주의점
생명주기로 정해진 메서드 외에 다른 함수에서 this로 state에 접근하려면 쓰려면 항상 bind(this)로 바인딩 해줘야한다. 근데 함수선언식 말고 화살표함수로 쓰면 괜찮음(js에서 this가 쓰이는 방식처럼 차이가 있다)
화살표 함수에서의 this는 바깥의 컨텍스트를 공유하기 때문에 this를 써도 this가 무엇을 가르키는지 암

클래스 컴포넌트는 화면이 리렌더링 될 때 마다 자기가 선언해놓은 메서드를 사용한다
생성될 때 -> 컨스트럭터 -> 렌더 -> 업데이트 -> 디드마운트
업데이트 될 때 -> 렌더 -> 업데이트 -> 디드업데이트
제거할 때 -> 언마운트

정리 
컨스트럭터 : 스테이트 초기화 및 메서드 bind할 때 씀
디드 마운트 : dom노드 초기화 및 데이터 fetch
언마운트 : 타이머 제거 및 요청 취소, 구독 해제
함수 컴포넌트 : 이런 걸 hook으로 관리가능하다.


4. 공식 문서로 보는 event

합성 이벤트(SyntheticEvent)
모든 부라우저에서 이벤트를 동일하게 처리하기 위해 합성 이벤트 객체를 전달받는다.
js에서의 이벤트와는 조금 다르지만 결국 더 편하게 사용할 수 있도록 만들어져 있음.

react의 이벤트는 소문자 대신 카멜케이스를 사용한다
jsx를 사용하여 문자열이 아닌 함수로 이벤트 핸들러를 전달한다(중괄호)

버블링?
이벤트 순서는 최상단캡쳐링 -> 다음단계캡쳐링... -> 클릭한 자신이 불린 후 버블링이 일어남
자식보다 부모가 먼저 클릭을 인지하게 만들고 싶을 때 쓴다고 한다.

정리
합성이벤트 : 인터페이스는 같지만 완전히 대응되지는 않음
버블 / 캡쳐 : 순서 챕쳐 > ... 타겟 -> 버블
return false : js에선 이걸로 동작을 막을 수 있었지만 react에선 못 쓰고 e.preventDefault()를 줘야함
