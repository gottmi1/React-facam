기본 : 라이브러리는 그들이 만든 목적과 도구의 사용법을 정리해뒀다
문서 리딩 및 예제를 반복, 숙달하며 공식문서에 익숙해져야 한다

익스텐션을 사용한 숏컷

react snippets 확장 프로그램을 받으면 rfc 익스텐션으로 리액트 펑션컴포넌트를 바로 만들 수 있음.
rcc는 클래스형 컴포넌트

1. 공식문서에서의 jsx

js를 확장한 문법. React의 엘리먼트를 생성한다.
React.createElement의 간편 표현식이다.

UI로직과 렌더링 로직이 연결되기 때문에 컴포넌트라는 유닛으로 묶어준다

따옴표를 사용하여 문자열 리터럴을 정의할 수 있고
중괄호를 사용하여 자바스크립트 표현식도 사용할 수 있다

React.createElement('h1', {className="zz"}, 'zdzd' )
를
<h1 className="zz">zdzd</h1>식으로 바꿔줌


2. 공식문서 에서의 컴포넌트와 Props

컴포넌트의 첫 글자는 반드시 대문자여야 하는데 이유는 기존의 html의 
태그나 프로퍼티와 중복될 수가 있기 때문이다.

컴포넌트 합성
부모 컴포넌트에 밖에있는 다른 컴포넌트를 요소로서 넣을 수가 있다.


컴포넌트 추출
유의미한 값들을 추출해서 새로운 컴포넌트를 만드는 것
재사용성을 높이는 방법 중 하나.

한 컴포넌트에 여러가지가 들어가는 것 보다 그걸 분해해서 여러가지 컴포넌트로 만들어놓는다면 재사용이 가능해서 편하다. 특히 버튼등. 작은 앱에선 굳이 왜하나싶지만 큰 앱에서 작업할 때 몹시 편함.

Props
★컴포넌트에 전달되는 단일객체, 모든 값이 들어있다
props는 읽기 전용이다
입력값을 바꾸지 않고 입력값에 대해 동일한 결과를 반환하는데, 이것을 순순함수라고 한다.
모든 React 컴포넌트는 자신의 props를 다룰 때 항상 순수 함수처럼 동작해야 한다.

정리 : 
props -> 컴포넌트에 전달되는 단일 객체. 모든 프로퍼티를 포함하고 있기 때문에 props.name 식으로 하나의 값에만 접근하는 것도 가능.
컴포넌트 합성 작은 컴포넌트를 여러개 모아 한 컴포넌트를 만들 수 있음
컴포넌트 추출 여러곳에서 사용되거나 크고 복잡한 경우 요소요소를 따로 컴포넌트로 지정할 수 있음


3. 공식문서로 보는 State 와 생명주기(LifeCycle)

hook들이 나오기 전에는 함수형 컴포넌트에서 상태관리를 할 수가 없었다 hook을 사용하고 부터 상태 관리가 가능해짐(보통 더 많이 쓰인다고 한다)
중요한 점은 생명주기를 useEffect만으로 대체할 수 있다는 점.

정리 : 
컴포넌트 내의 상태) 자신의 출력값만 변경(props는 변경하면 안됨)
클래스 컴포넌트) 스테이트의 라이프사이클 별로 메서드가 있는데 그걸 통해서 상태를 관리함
함수 컴포넌트 에선 hook으로 관리함.
유의사항) 직접 수정이 불가능하고 비동기적일 수 있음.
State를 직접 설정하면 안된다 클래스 컴포넌트에선 this.state식으로 접근하기 떄문에 값을 변경할 수가 있는데 그렇게 하면 리렌더링이 되지 않으니 그렇게 사용하면 안된다.
State의 업데이트는 비동기적일 수 있다.

결론 : 함수 컴포넌트로도 클래스 컴포넌트와 똑같은 동작을 할 수 있고 그 안에서 상태관리가 가능하다.

3-2. 생명주기(LifeCycle)

툴을 쓸 때 어떤 타이밍에 어떤 순서로 동작이 일어나는가 하는 생성되고 사라지는 주기를 가르킨다

클래스 컴포넌트에서 this 주의점
생명주기로 정해진 메서드 외에 다른 함수에서 this로 state에 접근하려면 쓰려면 항상 bind(this)로 바인딩 해줘야한다. 근데 함수선언식 말고 화살표함수로 쓰면 괜찮음(js에서 this가 쓰이는 방식처럼 차이가 있다)
화살표 함수에서의 this는 바깥의 컨텍스트를 공유하기 때문에 this를 써도 this가 무엇을 가르키는지 암

클래스 컴포넌트는 화면이 리렌더링 될 때 마다 자기가 선언해놓은 메서드를 사용한다
생성될 때 -> 컨스트럭터 -> 렌더 -> 업데이트 -> 디드마운트
업데이트 될 때 -> 렌더 -> 업데이트 -> 디드업데이트
제거할 때 -> 언마운트

정리 
컨스트럭터 : 스테이트 초기화 및 메서드 bind할 때 씀
디드 마운트 : dom노드 초기화 및 데이터 fetch
윌언마운트 : 타이머 제거 및 요청 취소, 구독 해제
함수 컴포넌트 : 이런 걸 hook으로 관리가능하다.


4. 공식 문서로 보는 event

합성 이벤트(SyntheticEvent)
모든 부라우저에서 이벤트를 동일하게 처리하기 위해 합성 이벤트 객체를 전달받는다.
js에서의 이벤트와는 조금 다르지만 결국 더 편하게 사용할 수 있도록 만들어져 있음.

react의 이벤트는 소문자 대신 카멜케이스를 사용한다
jsx를 사용하여 문자열이 아닌 함수로 이벤트 핸들러를 전달한다(중괄호)

버블링?
이벤트 순서는 최상단캡쳐링 -> 다음단계캡쳐링... -> 클릭한 자신이 불린 후 버블링이 일어남
자식보다 부모가 먼저 클릭을 인지하게 만들고 싶을 때 쓴다고 한다.

정리
합성이벤트 : 인터페이스는 같지만 완전히 대응되지는 않음
버블 / 캡쳐 : 순서 챕쳐 > ... 타겟 -> 버블
return false : js에선 이걸로 동작을 막을 수 있었지만 react에선 못 쓰고 e.preventDefault()를 줘야함


5. 조건부 렌더링(conditional rendering)

js의 조건부 렌더링과 비슷하다.
true && expression은 항상 expression으로 평가되고 fasle && expression 은 항상 false로 평가된다. 숫자 0은 false한 값이므로 그 부분은 신경써야 한다.

정리
if : if(conditional){return A}else{return B}
&& : condition && A, condition이 true이면 A가 그려지고 false면 아무것도 안 그려짐. 그러나 값이 falsy할 때(빈 문자열, 언디파인드, 널, 숫자 0 등)는 condition이 그려질 수도 있음 그럴때는 falsy한 값을 Boolean()으로 감싸주거나 삼항 연산자를 써라
삼항연산자 : condition ? A : B 트루일 떄 A false일 때 B
아예 안 그리고싶은 경우 : return null

6. List 와 Key

List는 array라고 생각하면 됨.

리액트에서 배열을 엘리먼트 리스트로 만드는 방식은 js에서 map()을 쓰는 것과 비슷하다.
엘리먼트 리스트를 만들 때 key값을 넣어야 한다는 경고가 표시되기 때문에 어트리부트로 key를 넣어주어야 한다.

key는 리액트가 어떤 항목을 변경,추가,삭제할 때 식별하는 것을 돕는다. 고유해야하기 때문에 배열 내부의 엘리먼트에 지정한다(map할 때). 대부분의 경우 데이터의 id를 key로 사용한다.
그리고 형제 사이에서만 고유하면 됨 모든 배열에서 고유할 필요는 없다.

정리
map : 배열의 개별요소를 순회, 두 번째 인자로 인덱스 값을 받음.
default Key : key를 안 주면 warning이 뜨긴 하지만 react가 자동으로 index를 key로 할당해서 쓰고 있다
고유성 : 컴포넌트 전체에서 고유할 필요 없이 형제들 사이에서만 고유하면 됨.
key props : key는 props로 넘기거나 받을 수 없다

7. Form

제어 컴포넌트 
컴포넌트 자체에 밸류를 주고 그 밸류를 state로 관리

대부분의 폼을 구현하는데 제어 컴포넌트를 사용하는 게 좋지만 폼데이터가 리액트 컴포넌트에서 다루어진다. 이러면 비효율적일 수 있는데
대안으로 비제어 컴포넌트로 DOM자체에서 폼 데이터가 다뤄지도록 할 수 있음.
핸들러를 사용하지 않고 ref를 사용한다.

정리
제어컴포넌트(controlledComponent)
input의 value를 state로 관리하는 것

다중입력 : 하나의 핸들러만 가지고 e.target.name,type,id 등.. 다양하게 사용 해서 if문으로 제어 가능

비제어컴포넌트(UnControlledComponent)
form element 자체의 내부 상태 활용
굳이 react로 state를 관리하지 않고 상태관리를 맡긴다
값을 볼 때는 ref를 주고 ref.current.value 등으로 꺼내 쓸 수 있다.

defaultValue , ref
기본값, value 확인