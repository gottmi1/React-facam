1. Hooks 1

리액트 16.8버전부터 새로 추가됨
Hook이 생기기 이전엔 클래스형 컴포넌트를 많이 사용했지만 이후론 함수형 컴포넌트를 많이 사용한다.(Hook을 많이 사용하고 있다)

만들어진 이유 :
컴포넌트 사이에서 상태 로직 재사용이 어렵다
복잡한 컴포넌트들은 이해하기 어렵다

class의 단점을 보완하면서 라이프사이클 등과 관련된 함수를 재사용 가능하게 한다

Hook의 사용 규칙

컴포넌트의 최상위에서 호출 되어야 한다. 반복문,조건문,중첩된 함수에서 Hook을 실행하면 원하지 않는 사이드이펙트들이 일어날 수 있다
함수 컴포넌트에서만 호출해야한다.

정리
Hooks 등장 -> Class의 단점 보완 / 재사용성 강화
사용규칙 -> 최상위에서 호출, 함수형 컴포넌트에서만 쓴다
Class의 State -> 그냥 이런게 있구나 정도만 알고 Hooks를 쓰자


2. Hooks 2

useEffect 
데이터 fetch,구독,DOM수정등 사이드 이펙트를 다룰때 쓴다.

클린 업
구독과 구독 해지,셋인터벌,클리어 등을 한 공간에서 할 수 있게 함

dependency array 
의존성 배열을 줘서 의도대로 실행 가능

3. Hooks 3

커스텀 훅
비슷한 동작을 하는 훅들의 묶음. 재사용 될 여지가 있을 때 이렇게 만들어주면 좋다
Hook에서 Hook으로 정보 전달 가능.

useState : 이전값을 인자로(prev) / 초기화 지연 레이지 이니셜라이즈(set 값을 함수로)

useEffect : 의존성 배열, 안주거나 빈배열을 줄 수도 있음

useLayoutEffect : useEffect와 유사하나 모든 DOM변경 후 브라우저가 화면을 그리기 이전 시점에 동기적으로 수행된다.

useReducer : useState의 상위호환 state / redcuer / action 

useRef : current라는 상자. 내용의 변경을 알려주지는 않기때문에 콜백Ref 사용해야 함


4. 중간정리(1)

Hooks 등장 -> Class의 단점 보완 / 재사용성 강화
사용규칙 -> 최상위에서 호출, 함수형 컴포넌트에서만 쓴다
Class의 State -> 그냥 이런게 있구나 정도만 알고 Hooks를 쓰자

useEffect -> 데이터 fetch,구독,DOM수정등 사이드 이펙트를 다룰때 쓴다.
클린 업 -> 구독과 구독 해지,셋인터벌,클리어 등을 한 공간에서 할 수 있게 함
dependency array -> 의존성 배열을 줘서 의도대로 실행 가능

CustomHook -> 반복되는 Hooks를 하나로 묶어줄 수 있다.

한국어 공식문서는 접근성은 좋지만 저자의 의도를 놓치거나 하는 경우가 있을 수 있음
원어로 보는것이 중요하다(번역기를 사용하더라도)

5. Composition(합성) 과 Inheritance(상속)

리액트에선 상속 대신 합성을 사용하여 컴포넌트 간에 코드를 재사용하는 것이 좋다

컴포지션 : 컴포넌트에 다른 컴포넌트를 담는 것.
담는 방법 : children / custom

상속 : 컴포지션이 있으면 굳이 쓸 필요가 없다

typeof로 type을 체크
다양한 상황에 대응 가능하도록할 수 있음

6. HOC(Higher Order Component) 

컴포넌트 로직을 재사용하기 위한 React의 고급 기술을 고차 컴포넌트라고 한다 Api의 일부가 아니고 리액트 구성적 특성에서 나오는 패턴이다
동작 : 인자로 받은 컴포넌트를 가져와서 새 컴포넌트를 반환하는 함수 

7. Memoization

프로그램이 동일한 계산을 반복해야 할 때 이전에 계산한 값,함수,변수를 메모리에 저장함으로써 동일한 계산의 방복 수행을 제거하여 프로그램의 실행 속도를 빠르게 하는 기술

동일한 props로 렌더링 한다면 React.memo를 사용해 성능을 향상시킬 수 있다.
memo를 사용하면 React 컴포넌트를 렌더링하지 않고 마지막으로 렌더링 된 결과를 재사용한다


정리 
React.memo -> HOC이다. props를 비교하여 바뀌지 않았다면 기존 컴포넌트를 그대로 쓴다
Profiler -> 리액트 성능 분석 도구
useCallback -> 전달되는 '함수'를 메모리제이션 해준다
useMemo -> 전달되는 '값(value)'을 메모리제이션 해준다

useCallback(fn,deps) === useMemo(() => fn, deps) 같은 거다(js에선 함수도 값으로 인식하기 때문)

8. Context

컴포넌트 트리를 넘어 데이터를 공유할 수 있는 방법.
props를 인접 컴포넌트가 아닌 컴포넌트로 공유하는 방법은 공유 가능한 부모까지 끌어올리고 거기서 공유할 컴포넌트로 내려가야하는 비효율이 있는데 컨텍스트를 사용하면 자유롭게 공유 가능하다

앱 전체에서 알아야 할 전역적인 데이터(페이지 상단의 언어, 나이트 모드, 장바구니 등)가 있을 땐 컨텍스트로 관리해 주는 것이 편하다

컴포넌트 트리 제약 -> Props drilling의 한계를 해소
재사용성↓ -> Context로 감싸여야만 온전한 동작을 하기 때문에 재사용하기 좀 어렵다
Api 구조 -> createContext / Provider(공급) / Consumer(소비)
useContext -> Consumer 대체

9. Portals

Dom계층 구조 바깥에 있는 Dom노드로 자식을 렌더링하는 가장 좋은 방법
modal같은 것에 주로 쓰임
createPortal -> react-dom을 객체분해해서 import한다. 부모 컴포넌트의 Dom트리로 부터 벗어날 수 있음(기본적으로 root가 최상위 부모이다)
이벤트 -> portal에 렌더 되더라도, 이벤트는 트리로 전파함

10. render props

컴포넌트를 재사용하기 위한 방법 중 하나 (컴포지션, HOC, 렌더 프랍스 ...)

