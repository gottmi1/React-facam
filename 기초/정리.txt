1. 리액트 기본

1)컴포넌트 -> 엘리먼트의 집합

생긴거

const component = () => {
  return <>
    <button value="1"/>
    <input />
  </>
}
<> <-- 빈 소괄호는 fragment인데 한 컴포넌트에는 반드시 하나의 root요소를 가져야하기 때문에 만들어주는 거. <div></div>이걸로 해도 되지만 그렇게 되면 중첩될수록 쓸데없이 렌더되는 요소의 수가 많아져서 안 씀.

2)useState -> 상태(State)를 관리해주는 hook(리액트의 라이브러리같은 것)
useState는 두개의 값을 구조분해할당하는데, [a,setA] = useState() 로 하는 것이 관행이며 첫번째 인자는 현재 값(현재의 상태, useState()괄호 안에 들어간 거. setState의 최초값이기도 함.)이고, 두번째 값은 그 값을 교체해 렌더해주는 함수이다.



2.컴포넌트의 사이드 이펙트

1)사이드 이펙트 -> 부수효과를 의도적으로 낼때 사용

2)useState는 lazy initalize를 할 수 있다.
useState() <-- 이 괄호안에 함수를 넣어주는 형식
왜 쓰는가? 무언가 가져와야 하는 값이 있는데 딜레이가 있을 수 있는 경우, 그 딜레이 후에 동작하도록 해줌(안정성↑)

3)useEffect의 dipendency array
두번째 인자로 오는 배열
아예 안 쓰면 모든 동작에서 실행(express.use와 같음)
[] 이면 처음 렌더될 때 한번만 실행
[abcd] 이면 abcd의 상태에 변화가 생겼을 때마다 실행된다.


3. 커스텀 훅 만들기

1)반복

useState나 useEffect등이 같은 요소의 상태변화로 실행될 때 비슷한 코드의 반복이 일어날 수 있음. 그 둘을 묶어서 한 함수로 만들어 쓰면 더 보기 편하다 재사용할 수 있는 것도 장점.
이름 짓는 관행 : useName 이런식으로 hook임을 나타내는 use를 사용하고 뒤에 이름은 아무거나 카멜케이스로 작성.


4. hook flow

1)hook들의 호출 타이밍
app 렌더 -> child렌더 -> app 클린업(최초 실행 후) -> child 클린업(최초 실행 후) -> child 이펙트 -> app 이펙트 순서로 동작됨
여러번 해봐야할듯

2)useState의 이전 값
최초에 setState에 지정되어 있는 상태를 setState(prev => {return !prev}) 이런식으로 불러올 수 있다. 위의 예를 든 함수는 불린형태를 계속 바꿔주는 함수

3) useEffect

렌더가 끝난 후 시작
app보다 children의 이펙트가 먼저 실행 됨.

4)update시 (useEffect의 클린업)

useEffect에는 return으로 클린업 함수를 실행 가능함
update할 때 effect의 첫 실행 전에는 실행되지 않다가, 처음 실행 된 후부터는 effect보다 먼저 실행됨




